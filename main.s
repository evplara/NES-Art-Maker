;
; File generated by cc65 v 2.19 - Git 3d7e388
;
	.fopt		compiler,"cc65 v 2.19 - Git 3d7e388"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	c_sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.export		_main

; ---------------------------------------------------------------
; void __near__ wait_vblank (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_wait_vblank: near

.segment	"CODE"

;
; while (PPUSTATUS & 0x80) {
;
L0008:	lda     $2002
	and     #$80
	bne     L0008
;
; while (!(PPUSTATUS & 0x80)) {
;
L0009:	lda     $2002
	and     #$80
	beq     L0009
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ read_joy1 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_read_joy1: near

.segment	"CODE"

;
; uint8_t buttons = 0;
;
	jsr     decsp1
	lda     #$00
	jsr     pusha
;
; JOY1 = 1;
;
	lda     #$01
	sta     $4016
;
; JOY1 = 0;
;
	lda     #$00
	sta     $4016
;
; for (i = 0; i < 8u; ++i) {
;
	ldy     #$01
L0007:	sta     (c_sp),y
	cmp     #$08
	bcs     L0003
;
; if (JOY1 & 1) {
;
	lda     $4016
	and     #$01
	beq     L0009
;
; buttons |= (1u << i);
;
	ldy     #$00
	lda     (c_sp),y
	sta     ptr1
	iny
	lda     (c_sp),y
	tay
	lda     #$01
L000A:	asl     a
	dey
	bpl     L000A
	ror     a
	ora     ptr1
	ldy     #$00
	sta     (c_sp),y
;
; for (i = 0; i < 8u; ++i) {
;
	iny
L0009:	clc
	lda     #$01
	adc     (c_sp),y
	jmp     L0007
;
; return buttons;
;
L0003:	ldx     #$00
	lda     (c_sp,x)
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_write (unsigned int addr, unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_write: near

.segment	"CODE"

;
; static void ppu_write(uint16_t addr, uint8_t value) {
;
	jsr     pusha
;
; PPUADDR = (uint8_t)(addr >> 8);     /* high byte */
;
	ldy     #$02
	lda     (c_sp),y
	sta     $2006
;
; PPUADDR = (uint8_t)(addr & 0xFF);   /* low byte  */
;
	dey
	lda     (c_sp),y
	sta     $2006
;
; PPUDATA = value;
;
	dey
	lda     (c_sp),y
	sta     $2007
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_clear_nametable (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_clear_nametable: near

.segment	"CODE"

;
; PPUADDR = 0x20;
;
	jsr     decsp2
	lda     #$20
	sta     $2006
;
; PPUADDR = 0x00;
;
	lda     #$00
	sta     $2006
;
; for (i = 0; i < 32u * 30u; ++i) {
;
	tay
	sta     (c_sp),y
	iny
	sta     (c_sp),y
L0002:	ldy     #$01
	lda     (c_sp),y
	cmp     #$03
	bne     L0006
	dey
	lda     (c_sp),y
	cmp     #$C0
L0006:	bcs     L0003
;
; PPUDATA = 0;
;
	lda     #$00
	sta     $2007
;
; for (i = 0; i < 32u * 30u; ++i) {
;
	tax
	lda     #$01
	jsr     addeq0sp
	jmp     L0002
;
; PPUADDR = 0x23;
;
L0003:	lda     #$23
	sta     $2006
;
; PPUADDR = 0xC0;
;
	lda     #$C0
	sta     $2006
;
; for (i = 0; i < 64u; ++i) {
;
	ldy     #$00
	tya
	sta     (c_sp),y
	iny
	sta     (c_sp),y
L0007:	ldy     #$01
	lda     (c_sp),y
	cmp     #$00
	bne     L000B
	dey
	lda     (c_sp),y
	cmp     #$40
L000B:	bcs     L0008
;
; PPUDATA = 0;
;
	lda     #$00
	sta     $2007
;
; for (i = 0; i < 64u; ++i) {
;
	tax
	lda     #$01
	jsr     addeq0sp
	jmp     L0007
;
; }
;
L0008:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ ppu_init_palette (unsigned char bg_color)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ppu_init_palette: near

.segment	"CODE"

;
; static void ppu_init_palette(uint8_t bg_color) {
;
	jsr     pusha
;
; PPUADDR = 0x3F;
;
	jsr     decsp1
	lda     #$3F
	sta     $2006
;
; PPUADDR = 0x00;
;
	lda     #$00
	sta     $2006
;
; PPUDATA = bg_color;
;
	ldy     #$01
	lda     (c_sp),y
	sta     $2007
;
; PPUDATA = 0x01;  /* dark blue */
;
	sty     $2007
;
; PPUDATA = 0x11;  /* medium blue */
;
	lda     #$11
	sta     $2007
;
; PPUDATA = 0x21;  /* light blue */
;
	lda     #$21
	sta     $2007
;
; for (i = 0; i < 12u; ++i) {
;
	lda     #$00
	dey
L0006:	sta     (c_sp),y
	cmp     #$0C
	bcs     L0003
;
; PPUDATA = 0x00;
;
	lda     #$00
	sta     $2007
;
; for (i = 0; i < 12u; ++i) {
;
	clc
	lda     #$01
	adc     (c_sp),y
	jmp     L0006
;
; }
;
L0003:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; uint8_t color = 0;
;
	lda     #$00
	jsr     pusha
;
; uint8_t prev_buttons = 0;
;
	jsr     pusha
;
; wait_vblank();
;
	jsr     _wait_vblank
;
; color = 0;  /* start from color 0 */
;
	lda     #$00
	ldy     #$01
	sta     (c_sp),y
;
; wait_vblank();
;
	jsr     _wait_vblank
;
; ppu_clear_nametable();
;
	jsr     _ppu_clear_nametable
;
; ppu_init_palette(0x0F);
;
	lda     #$0F
	jsr     _ppu_init_palette
;
; PPUCTRL = 0x00;    /* base nametable 0, no NMI */
;
	lda     #$00
	sta     $2000
;
; PPUMASK = 0x08;    /* show background, no sprites */
;
	lda     #$08
	sta     $2001
;
; wait_vblank();
;
L0005:	jsr     decsp1
	jsr     _wait_vblank
;
; buttons = read_joy1();
;
	jsr     _read_joy1
	ldy     #$00
	sta     (c_sp),y
;
; if ((buttons & 0x01u) && !(prev_buttons & 0x01u)) {
;
	and     #$01
	beq     L000E
	iny
	lda     (c_sp),y
	and     #$01
	bne     L0006
;
; ++color;
;
	iny
	clc
	lda     #$01
	adc     (c_sp),y
	sta     (c_sp),y
;
; if (color >= 0x40) {
;
	cmp     #$40
	bcc     L000A
;
; color = 0;
;
	lda     #$00
	sta     (c_sp),y
;
; ppu_write(0x3F00, color);
;
L000A:	ldx     #$3F
	lda     #$00
	jsr     pushax
	ldy     #$04
	lda     (c_sp),y
	jsr     _ppu_write
;
; prev_buttons = buttons;
;
L0006:	ldy     #$00
L000E:	lda     (c_sp),y
	iny
	sta     (c_sp),y
;
; }
;
	jsr     incsp1
	jmp     L0005

.endproc

